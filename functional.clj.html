<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>~/odds-and-ends/functional.clj.html</title>
<meta name="Generator" content="Vim/7.2">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<style type="text/css">
<!--
.Number { color: #0000c0; }
.clojureParen5 { color: #ff6060; }
.clojureParen4 { color: #ff40ff; }
.Error { color: #ffffff; background-color: #ff6060; }
.clojureParen3 { color: #00ffff; }
.Comment { color: #00ffff; }
.PreProc { color: #c00000; }
.Constant { color: #af5f00; }
.clojureParen2 { color: #00ff00; }
.Statement { color: #00ff00; }
.clojureParen1 { color: #ffff00; }
.Special { color: #ff40ff; }
.Identifier { color: #008000; font-weight: bold; }
pre { font-family: monospace; color: #ffffff; background-color: #000000; }
body { font-family: monospace; color: #ffffff; background-color: #000000; }
.lnr { color: #ffff00; }
-->
</style>
</head>
<body>
<pre>
<span class="lnr">  1 </span><span class="Special">(</span><span class="Identifier">require</span> <span class="Special">'</span><span class="Special">[</span>clojure.zip <span class="Statement">:as</span> zip<span class="Special">])</span>
<span class="lnr">  2 </span><span class="Special">(</span><span class="Identifier">import</span> <span class="Special">'</span><span class="clojureParen1">(</span>java.util LinkedList Collections<span class="clojureParen1">)</span><span class="Special">)</span>
<span class="lnr">  3 </span>
<span class="lnr">  4 </span><span class="Comment">;(load-file &quot;/home/kpd/odds-and-ends/functional.clj&quot;)</span>
<span class="lnr">  5 </span>
<span class="lnr">  6 </span><span class="Special">(</span><span class="PreProc">defn</span> shuffle
<span class="lnr">  7 </span>      <span class="Constant">&quot;return a shuffled collection of the same type</span>
<span class="lnr">  8 </span><span class="Constant">      and constituted from the same elementss as the</span>
<span class="lnr">  9 </span><span class="Constant">      collection passed in&quot;</span>
<span class="lnr"> 10 </span>      <span class="Special">[</span>x<span class="Special">]</span>
<span class="lnr"> 11 </span>      <span class="Special">(</span><span class="Special">let</span> <span class="Special">[</span>a <span class="Special">(</span>LinkedList. x<span class="Special">)]</span>
<span class="lnr"> 12 </span>        <span class="clojureParen1">(</span>Collections/shuffle a<span class="clojureParen1">)</span>
<span class="lnr"> 13 </span>        <span class="clojureParen1">(</span><span class="Statement">cond</span>
<span class="lnr"> 14 </span>          <span class="clojureParen2">(</span><span class="Identifier">vector?</span> x<span class="clojureParen2">)</span> <span class="clojureParen2">(</span><span class="Identifier">vec</span> a<span class="clojureParen2">)</span>
<span class="lnr"> 15 </span>          <span class="clojureParen2">(</span><span class="Identifier">set?</span> x<span class="clojureParen2">)</span>    <span class="clojureParen2">(</span><span class="Identifier">set</span> a<span class="clojureParen2">)</span>
<span class="lnr"> 16 </span>          <span class="clojureParen2">(</span><span class="Identifier">seq?</span> x<span class="clojureParen2">)</span>    <span class="clojureParen2">(</span><span class="Identifier">seq</span> a<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 17 </span>
<span class="lnr"> 18 </span><span class="Special">(</span><span class="PreProc">defn</span> transform
<span class="lnr"> 19 </span>      <span class="Constant">&quot;ugh, read the source. this started as a very specific function</span>
<span class="lnr"> 20 </span><span class="Constant">      and turned into a very generic one.&quot;</span>
<span class="lnr"> 21 </span>      <span class="Special">[</span>se pred <span class="Special">fn</span> adv fin<span class="Special">]</span>
<span class="lnr"> 22 </span>      <span class="Special">(</span><span class="Special">loop</span> <span class="Special">[</span>se se<span class="Special">]</span>
<span class="lnr"> 23 </span>            <span class="clojureParen1">(</span><span class="Special">if</span> <span class="clojureParen2">(</span>fin se<span class="clojureParen2">)</span>
<span class="lnr"> 24 </span>              se
<span class="lnr"> 25 </span>              <span class="clojureParen2">(</span><span class="Special">if</span> <span class="clojureParen3">(</span>pred se<span class="clojureParen3">)</span>
<span class="lnr"> 26 </span>                <span class="clojureParen3">(</span><span class="Statement">recur</span> <span class="clojureParen4">(</span>adv <span class="clojureParen5">(</span><span class="Special">fn</span> se<span class="clojureParen5">)</span><span class="clojureParen4">)</span><span class="clojureParen3">)</span>
<span class="lnr"> 27 </span>                <span class="clojureParen3">(</span><span class="Statement">recur</span> <span class="clojureParen4">(</span>adv se<span class="clojureParen4">)</span><span class="clojureParen3">)</span><span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 28 </span>
<span class="lnr"> 29 </span><span class="Special">(</span><span class="PreProc">defn</span> transforml
<span class="lnr"> 30 </span>      <span class="Constant">&quot;like transformr, but walks the zipper from the left&quot;</span>
<span class="lnr"> 31 </span>      <span class="Special">[</span>se pred <span class="Special">fn</span><span class="Special">]</span>
<span class="lnr"> 32 </span>      <span class="Special">(</span>transform se pred <span class="Special">fn</span> zip/next zip/end?<span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 33 </span>
<span class="lnr"> 34 </span><span class="Special">(</span><span class="PreProc">defn</span> transformr
<span class="lnr"> 35 </span>      <span class="Constant">&quot;takes a zipper, a predicate, and a function</span>
<span class="lnr"> 36 </span><span class="Constant">      walks the zipper from the current node towards the left</span>
<span class="lnr"> 37 </span><span class="Constant">      until the the end. fn is applied to any loc where pred is true&quot;</span>
<span class="lnr"> 38 </span>      <span class="Special">[</span>se pred <span class="Special">fn</span><span class="Special">]</span>
<span class="lnr"> 39 </span>      <span class="Special">(</span>transform se pred <span class="Special">fn</span> zip/prev <span class="clojureParen1">(</span><span class="Identifier">comp</span> <span class="Identifier">not</span> zip/prev<span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 40 </span>
<span class="lnr"> 41 </span><span class="Special">(</span><span class="Special">def</span> <span class="Special">#^</span><span class="Special">{</span><span class="Statement">:doc</span> <span class="Constant">&quot;fast forward the loc of a zipper to the lastnode reached by zip/next&quot;</span><span class="Special">}</span>
<span class="lnr"> 42 </span>     fast-fwd
<span class="lnr"> 43 </span>     <span class="Special">(</span><span class="Identifier">comp</span> <span class="Identifier">last</span>
<span class="lnr"> 44 </span>           <span class="clojureParen1">(</span><span class="Identifier">partial</span> <span class="Identifier">take-while</span> <span class="clojureParen2">(</span><span class="Identifier">comp</span> <span class="Identifier">not</span> zip/end? zip/next<span class="clojureParen2">)</span><span class="clojureParen1">)</span>
<span class="lnr"> 45 </span>           <span class="clojureParen1">(</span><span class="Identifier">partial</span> <span class="Identifier">iterate</span> zip/next<span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 46 </span>
<span class="lnr"> 47 </span><span class="Special">(</span><span class="PreProc">defn</span> uncurry
<span class="lnr"> 48 </span>      <span class="Constant">&quot;applied to a function it returns a function that will continue</span>
<span class="lnr"> 49 </span><span class="Constant">      partially applying until it is called with no arguments&quot;</span>
<span class="lnr"> 50 </span>      <span class="Special">[</span>x<span class="Special">]</span>
<span class="lnr"> 51 </span>      <span class="Special">(</span><span class="Special">fn</span> uc <span class="Special">[</span><span class="Special">&amp;</span> y<span class="Special">]</span>
<span class="lnr"> 52 </span>          <span class="clojureParen1">(</span><span class="Special">if</span> <span class="clojureParen2">(</span><span class="Identifier">seq</span> y<span class="clojureParen2">)</span>
<span class="lnr"> 53 </span>            <span class="clojureParen2">(</span>uncurry <span class="clojureParen3">(</span><span class="Identifier">apply</span> <span class="Identifier">partial</span> x y<span class="clojureParen3">)</span><span class="clojureParen2">)</span>
<span class="lnr"> 54 </span>            <span class="clojureParen2">(</span>x<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 55 </span>
<span class="lnr"> 56 </span><span class="Special">(</span><span class="PreProc">defn</span> flip
<span class="lnr"> 57 </span>      <span class="Constant">&quot;takes a function and returns a function that takes</span>
<span class="lnr"> 58 </span><span class="Constant">      arguments in the opposite order&quot;</span>
<span class="lnr"> 59 </span>      <span class="Special">[</span>x<span class="Special">]</span>
<span class="lnr"> 60 </span>      <span class="Special">(</span><span class="Special">fn</span> <span class="Special">[</span><span class="Special">&amp;</span> y<span class="Special">]</span>
<span class="lnr"> 61 </span>          <span class="clojureParen1">(</span><span class="Identifier">apply</span> x <span class="clojureParen2">(</span><span class="Identifier">reverse</span> y<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr"> 62 </span>
<span class="lnr"> 63 </span><span class="Special">(</span><span class="PreProc">defn</span> call <span class="Constant">&quot;(apply x y)&quot;</span> <span class="Special">[</span>x <span class="Special">&amp;</span> y<span class="Special">]</span> <span class="clojureParen1">(</span><span class="Identifier">apply</span> x y<span class="clojureParen1">)</span><span class="Special">)</span>
<span class="lnr"> 64 </span>
<span class="lnr"> 65 </span><span class="Special">(</span><span class="PreProc">defn</span> dollar-sign-application
<span class="lnr"> 66 </span>      <span class="Constant">&quot;walks backwards through a zipper turning a $ b into (a b)&quot;</span>
<span class="lnr"> 67 </span>      <span class="Special">[</span>zip<span class="Special">]</span>
<span class="lnr"> 68 </span>      <span class="Special">(</span>transformr zip
<span class="lnr"> 69 </span>                  <span class="Special">#(</span><span class="Identifier">=</span> <span class="Constant">&quot;$&quot;</span> <span class="Special">(</span><span class="PreProc">and</span> <span class="clojureParen1">(</span><span class="Identifier">symbol?</span> <span class="clojureParen2">(</span>zip/node %<span class="clojureParen2">)</span><span class="clojureParen1">)</span> <span class="clojureParen1">(</span><span class="Identifier">name</span> <span class="clojureParen2">(</span>zip/node %<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">))</span>
<span class="lnr"> 70 </span>                  <span class="Special">#(</span><span class="Special">let</span> <span class="Special">[</span>n <span class="Special">(</span><span class="Identifier">list</span> <span class="clojureParen1">(</span>zip/node <span class="clojureParen2">(</span>zip/left %<span class="clojureParen2">)</span><span class="clojureParen1">)</span> <span class="clojureParen1">(</span>zip/node <span class="clojureParen2">(</span>zip/right %<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)]</span>
<span class="lnr"> 71 </span>                     <span class="Special">(</span><span class="PreProc">-&gt;</span> % zip/remove <span class="clojureParen1">(</span>zip/insert-left n<span class="clojureParen1">)</span> zip/right zip/remove zip/remove<span class="Special">)))</span><span class="Error">)</span>
<span class="lnr"> 72 </span>
<span class="lnr"> 73 </span><span class="Special">(</span><span class="PreProc">defn</span> interpunc-comp
<span class="lnr"> 74 </span>      <span class="Constant">&quot;walks through a zipper tuning a · b into (comp a b)&quot;</span>
<span class="lnr"> 75 </span>      <span class="Special">[</span>zip<span class="Special">]</span>
<span class="lnr"> 76 </span>      <span class="Special">(</span>transforml zip
<span class="lnr"> 77 </span>                  <span class="Special">#(</span><span class="Identifier">=</span> <span class="Constant">&quot;·&quot;</span> <span class="Special">(</span><span class="Special">let</span> <span class="Special">[</span>c <span class="Special">(</span>zip/node %<span class="Special">)]</span> <span class="clojureParen1">(</span><span class="PreProc">and</span> <span class="clojureParen2">(</span><span class="Identifier">symbol?</span> c<span class="clojureParen2">)</span> <span class="clojureParen2">(</span><span class="Identifier">name</span> c<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">))</span>
<span class="lnr"> 78 </span>                  <span class="Special">#(</span><span class="Special">let</span> <span class="Special">[</span>n <span class="Special">(</span><span class="Identifier">list</span> <span class="Special">'</span><span class="Identifier">comp</span> <span class="clojureParen1">(</span>zip/node <span class="clojureParen2">(</span>zip/left %<span class="clojureParen2">)</span><span class="clojureParen1">)</span> <span class="clojureParen1">(</span>zip/node <span class="clojureParen2">(</span>zip/right %<span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)]</span>
<span class="lnr"> 79 </span>                     <span class="Special">(</span><span class="PreProc">-&gt;</span> % zip/left <span class="clojureParen1">(</span>zip/insert-left n<span class="clojureParen1">)</span>
<span class="lnr"> 80 </span>                         zip/remove zip/next zip/remove zip/next zip/remove<span class="Special">)))</span><span class="Error">)</span>
<span class="lnr"> 81 </span><span class="Special">(</span><span class="PreProc">defn</span> prefix-uncurry
<span class="lnr"> 82 </span>      <span class="Constant">&quot;walks through a zipper and turns ⌽a into (uncurry a)&quot;</span>
<span class="lnr"> 83 </span>      <span class="Special">[</span>zip<span class="Special">]</span>
<span class="lnr"> 84 </span>      <span class="Special">(</span>transforml zip
<span class="lnr"> 85 </span>                  <span class="Special">#(</span><span class="Identifier">=</span> <span class="Number">9021</span> <span class="Special">(</span><span class="PreProc">and</span> <span class="clojureParen1">(</span><span class="Identifier">symbol?</span> <span class="clojureParen2">(</span>zip/node %<span class="clojureParen2">)</span><span class="clojureParen1">)</span> <span class="clojureParen1">(</span>.codePointAt <span class="clojureParen2">(</span><span class="Identifier">name</span> <span class="clojureParen3">(</span>zip/node %<span class="clojureParen3">)</span><span class="clojureParen2">)</span> <span class="Number">0</span><span class="clojureParen1">)</span><span class="Special">))</span>
<span class="lnr"> 86 </span>                  <span class="Special">#(</span><span class="PreProc">-&gt;</span> <span class="Special">%</span> <span class="Special">(</span>zip/replace <span class="clojureParen1">(</span><span class="Identifier">list</span> <span class="Special">'</span>uncurry <span class="clojureParen2">(</span><span class="Identifier">symbol</span> <span class="clojureParen3">(</span><span class="Identifier">subs</span> <span class="clojureParen4">(</span><span class="Identifier">name</span> <span class="clojureParen5">(</span>zip/node %<span class="clojureParen5">)</span><span class="clojureParen4">)</span> <span class="Number">1</span><span class="clojureParen3">)</span><span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)))</span><span class="Error">)</span>
<span class="lnr"> 87 </span>
<span class="lnr"> 88 </span><span class="Special">(</span><span class="PreProc">defn</span> prefix-flip
<span class="lnr"> 89 </span>      <span class="Constant">&quot;walks through a zipper and turns ↕a into (flip a)&quot;</span>
<span class="lnr"> 90 </span>      <span class="Special">[</span>zip<span class="Special">]</span>
<span class="lnr"> 91 </span>      <span class="Special">(</span>transforml zip
<span class="lnr"> 92 </span>                  <span class="Special">#(</span><span class="Identifier">=</span> <span class="Number">8597</span> <span class="Special">(</span><span class="PreProc">and</span> <span class="clojureParen1">(</span><span class="Identifier">symbol?</span> <span class="clojureParen2">(</span>zip/node %<span class="clojureParen2">)</span><span class="clojureParen1">)</span> <span class="clojureParen1">(</span>.codePointAt <span class="clojureParen2">(</span><span class="Identifier">name</span> <span class="clojureParen3">(</span>zip/node %<span class="clojureParen3">)</span><span class="clojureParen2">)</span> <span class="Number">0</span><span class="clojureParen1">)</span><span class="Special">))</span>
<span class="lnr"> 93 </span>                  <span class="Special">#(</span><span class="PreProc">-&gt;</span> <span class="Special">%</span> <span class="Special">(</span>zip/replace <span class="clojureParen1">(</span><span class="Identifier">list</span> <span class="Special">'</span>flip <span class="clojureParen2">(</span><span class="Identifier">symbol</span> <span class="clojureParen3">(</span><span class="Identifier">subs</span> <span class="clojureParen4">(</span><span class="Identifier">name</span> <span class="clojureParen5">(</span>zip/node %<span class="clojureParen5">)</span><span class="clojureParen4">)</span> <span class="Number">1</span><span class="clojureParen3">)</span><span class="clojureParen2">)</span><span class="clojureParen1">)</span><span class="Special">)))</span><span class="Error">)</span>
<span class="lnr"> 94 </span>
<span class="lnr"> 95 </span><span class="Special">(</span><span class="PreProc">defmacro</span> pl
<span class="lnr"> 96 </span>  <span class="Constant">&quot;replaces a $ b with (a b) walking right to left</span>
<span class="lnr"> 97 </span><span class="Constant">  replaces a · b with (comp a b) left to right</span>
<span class="lnr"> 98 </span><span class="Constant">  ⌽a with (uncurry a) left to right</span>
<span class="lnr"> 99 </span><span class="Constant">  ↕a with (flip a) left to right&quot;</span>
<span class="lnr">100 </span>  <span class="Special">[</span><span class="Special">&amp;</span> forms<span class="Special">]</span>
<span class="lnr">101 </span>  <span class="Special">`</span><span class="Special">(</span><span class="Special">do</span> <span class="Special">~@</span><span class="clojureParen1">(</span><span class="PreProc">-&gt;</span> forms zip/seq-zip fast-fwd dollar-sign-application
<span class="lnr">102 </span>             interpunc-comp zip/root zip/seq-zip
<span class="lnr">103 </span>             prefix-uncurry zip/root zip/seq-zip
<span class="lnr">104 </span>             prefix-flip zip/root<span class="clojureParen1">)</span><span class="Special">)</span><span class="Error">)</span>
<span class="lnr">105 </span>
<span class="lnr">106 </span><span class="Comment">;; (pl</span>
<span class="lnr">107 </span><span class="Comment">;;   (↕map (replicate 3 (↕apply vector $ (↕map range $ 10 inc · inc · inc) call · ⌽* $ 10 · call · (⌽+ -2) map)) shuffle))</span>
<span class="lnr">108 </span>
<span class="lnr">109 </span><span class="Comment">;; (pl</span>
<span class="lnr">110 </span><span class="Comment">;;   (↕map (↕map (replicate 3 (range 3)) call · (⌽map inc)) shuffle))</span>
</pre>
</body>
</html>
